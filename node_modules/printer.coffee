util = require("util")
repl = require("repl")
serialport = require("serialport")
GCode = require("./gcode").GCode
EventEmitter = require('events').EventEmitter

gcode = new GCode()
# util.log(gcode.get_code('sethotend').code)

Reactions = [
    [/t:([\.\d]+)\s+b:([\.\d]+)/, (m) ->
        hotend_temp = parseFloat(m[1])
        if @hotend_temp != hotend_temp
            @hotend_temp = hotend_temp
            @emit 'hotend_temp_change', hotend_temp

        bed_temp = parseFloat(m[2])
        if @bed_temp != bed_temp
            @bed_temp = bed_temp
            @emit 'bed_temp_change', bed_temp
    ],
    [/x:([\.\d]+)\s*y:([\.\d]+)\s*z:([\.\d]+)\s*e:([\.\d]+)/, (m) ->
        pos = [parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3])]
        if @position[0] != pos[0] or @position[1] != pos[1] or @position[2] != pos[2]
            @position = pos
            @emit 'position_change', pos

        extruder = parseFloat(m[4])
        if @extruder != extruder
            @extruder = extruder
            @emit 'extruder_change', extruder
    ]
]

interval = (millis, fn) -> setInterval fn, millis
timeout = (millis, fn) -> setTimeout fn, millis

class Printer extends EventEmitter
    constructor: (@port, @baud=115200) ->
        @serial = new serialport.SerialPort @port,
            parser: serialport.parsers.readline("\n")
            baudrate: @baud
        
        @monitor = null
        @state = 'init'
        @transition 'offline'
        
        # Unsent commands
        @command_queue = []

        # Responses
        @response_queue = []

        # Defaults
        @hotend_temp = 0.0
        @bed_temp = 0.0
        @position = [0.0, 0.0, 0.0]
        @extruder = 0.0

        @serial.on 'data', (line) => @read(line)
        @serial.on 'error', (msg) => @error(msg)
    
    start_monitor: (monitor_interval=1000) ->
        if not @monitor
            @monitor = interval monitor_interval, =>
                @command 'gettemp'
        return this
    
    end_monitor: ->
        clearInterval @monitor if @monitor
        return this

    # Callback for serial data stream    
    read: (line) ->
        util.log "Read: " + line
        if line.indexOf('T:') == -1
            @response_queue.push(line)
        @current_line = line.toLowerCase()
        @[@state](@current_line)
    
    # Error callback for serial port
    error: (msg) ->
        util.log "error: " + msg
        
    # Respond to info from the printer. This is called from both
    # the 'feedback' and 'prompt' states.
    react: (line) ->
        for [re, fn] in Reactions
            # util.log("Checking #{line} against #{re.toString()}")
            if m = line.match(re)
                util.log("Matched")
                fn.apply(this, [m]) 
    
    command: (cmd, options={}) ->
        if g = gcode.get_code(cmd)
            parts = [g.code]
            for k, v of options
                parts.push("#{k.toUpperCase()}#{v}")
            line = parts.join(' ') + "\r"
            # util.log("command_queueing Command #{g.name}: #{line}")
            @command_queue.push(line)
            @decommand_queue()
        else
            util.log("GCode for command '#{cmd}' not found.")
    
    decommand_queue: ->
        if @command_queue.length > 0 and @state == 'prompt'
            @current_line = @command_queue.shift()
            util.log("Sending: #{@current_line}")
            @serial.write(@current_line)
            @transition('feedback', true)
            return true
        else
            util.log "No decommand_queue for now (#{@state})"
            return false
                
    responses_since: (start, page_size=1000) ->
        len = @response_queue.length
        if len > 0 and start < len
            return @response_queue.slice(start, len-start)
        else
            return []


    # ------------- #
    # State Machine #
    # ------------- #

    # Simulate state machine
    # 'init'                  : Initial state
    # 'offline' -> 'contact'  : Transition on first 'start' (sometimes we get multiple 'start' signals)
    # 'contact' -> 'lobby'    : Transition to lobby after 2 seconds
    # 'lobby' -> 'prompt'     : Send a 'Get Temp' signal, and then transition on 'ok'
    # 'prompt' -> 'offline'   : Transition on reset or disconnect command (or on physical disconnect?)
    # 'prompt' -> 'feedback'  : Transition on any command except reset or disconnect
    # 'feedback' -> 'prompt'  : Transition on 'start' or 'ok'
    # 'feedback' -> 'offline' : Transition on physical disconnect, error

    # Transition from current state to given state. If
    # reprocess_line is true, then pass the current_line on to
    # the next state after transition as well.
    #
    # In addition to setting the state, transition callbacks
    # are also taken in to account. e.g. A_ is called when
    # leaving state 'A', _A is called when entering state 'A',
    # and A_B is called when leaving state A and entering state B.
    transition: (state, reprocess_line=false) ->
        util.log "Transition from #{@state} to #{state}"
        for transition_fn in ["#{@state}_", "_#{state}", "#{@state}_#{state}"]
            # util.log "Considering transition #{transition_fn}"
            if transition_fn of this
                util.log "Calling #{transition_fn}"
                @[transition_fn]()
        @state = state
        @[@state](@current_line) if reprocess_line
    
    # On transition to 'offline'    
    _offline: ->
        @start_signals = 0
        @emit('offline')
    
    # Callback when in 'offline' state    
    offline: (line) ->
        if line.indexOf('start') == 0
            @start_signals += 1
            @transition 'contact'
        else
            util.log "Offline. Ignoring: #{line}"
    
    # On transition to 'contact' state    
    _contact: () ->
        timeout 2000, => @transition 'lobby'
        @emit('contact')
    
    # Callback when in 'contact' state    
    contact: (line) ->
        if line.indexOf('start') == 0
            @start_signals += 1
            util.log "Extra 'start' signal detected."
        else
            util.log "Contact. Ignoring: #{line}"
    
    # On transition to 'lobby' state    
    _lobby: (line) ->
        util.log "Start signals received: #{@start_signals}"
        @serial.write "M105\r"
    
    # Callback when in 'lobby' state    
    lobby: (line) ->
        if line.indexOf('ok') == 0
            @transition 'prompt', true
        else
            util.log "Lobby. Ignoring: #{line}"

    lobby_: (line) ->
        @emit('online')
    
    # Callback when in 'feedback' state
    feedback: (line) ->
        if line.indexOf('ok') == 0
            @transition 'prompt', true
            @decommand_queue()
        else
            @react line
    
    # Callback when in 'prompt' state    
    prompt: (line) ->
        @react line
    
# printer = new Printer('/dev/tty.usbmodem621')
# printer.on 'offline', -> util.log('Went offline')
# printer.on 'contact', -> util.log('In contact')
# printer.on 'online', -> util.log('Went online')

# context = repl.start( "=>" ).context
# context.serial = printer.serial
# context.printer = printer

module.exports.Printer = Printer