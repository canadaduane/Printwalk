(function() {
  var EventEmitter, GCode, Printer, Reactions, gcode, interval, repl, serialport, timeout, util;
  var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  util = require("util");

  repl = require("repl");

  serialport = require("serialport");

  GCode = require("./gcode").GCode;

  EventEmitter = require('events').EventEmitter;

  gcode = new GCode();

  Reactions = [
    [
      /t:([\.\d]+)\s+b:([\.\d]+)/, function(m) {
        var bed_temp, hotend_temp;
        hotend_temp = parseFloat(m[1]);
        if (this.hotend_temp !== hotend_temp) {
          this.hotend_temp = hotend_temp;
          this.emit('hotend_temp_change', hotend_temp);
        }
        bed_temp = parseFloat(m[2]);
        if (this.bed_temp !== bed_temp) {
          this.bed_temp = bed_temp;
          return this.emit('bed_temp_change', bed_temp);
        }
      }
    ], [
      /x:([\.\d]+)\s*y:([\.\d]+)\s*z:([\.\d]+)\s*e:([\.\d]+)/, function(m) {
        var extruder, pos;
        pos = [parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3])];
        if (this.position[0] !== pos[0] || this.position[1] !== pos[1] || this.position[2] !== pos[2]) {
          this.position = pos;
          this.emit('position_change', pos);
        }
        extruder = parseFloat(m[4]);
        if (this.extruder !== extruder) {
          this.extruder = extruder;
          return this.emit('extruder_change', extruder);
        }
      }
    ]
  ];

  interval = function(millis, fn) {
    return setInterval(fn, millis);
  };

  timeout = function(millis, fn) {
    return setTimeout(fn, millis);
  };

  Printer = (function() {

    __extends(Printer, EventEmitter);

    function Printer(port, baud) {
      var _this = this;
      this.port = port;
      this.baud = baud != null ? baud : 115200;
      this.serial = new serialport.SerialPort(this.port, {
        parser: serialport.parsers.readline("\n"),
        baudrate: this.baud
      });
      this.monitor = null;
      this.state = 'init';
      this.transition('offline');
      this.command_queue = [];
      this.response_queue = [];
      this.hotend_temp = 0.0;
      this.bed_temp = 0.0;
      this.position = [0.0, 0.0, 0.0];
      this.extruder = 0.0;
      this.serial.on('data', function(line) {
        return _this.read(line);
      });
      this.serial.on('error', function(msg) {
        return _this.error(msg);
      });
    }

    Printer.prototype.start_monitor = function(monitor_interval) {
      var _this = this;
      if (monitor_interval == null) monitor_interval = 1000;
      if (!this.monitor) {
        this.monitor = interval(monitor_interval, function() {
          return _this.command('gettemp');
        });
      }
      return this;
    };

    Printer.prototype.end_monitor = function() {
      if (this.monitor) clearInterval(this.monitor);
      return this;
    };

    Printer.prototype.read = function(line) {
      util.log("Read: " + line);
      if (line.indexOf('T:') === -1) this.response_queue.push(line);
      this.current_line = line.toLowerCase();
      return this[this.state](this.current_line);
    };

    Printer.prototype.error = function(msg) {
      return util.log("error: " + msg);
    };

    Printer.prototype.react = function(line) {
      var fn, m, re, _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = Reactions.length; _i < _len; _i++) {
        _ref = Reactions[_i], re = _ref[0], fn = _ref[1];
        if (m = line.match(re)) {
          util.log("Matched");
          _results.push(fn.apply(this, [m]));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Printer.prototype.command = function(cmd, options) {
      var g, k, line, parts, v;
      if (options == null) options = {};
      if (g = gcode.get_code(cmd)) {
        parts = [g.code];
        for (k in options) {
          v = options[k];
          parts.push("" + (k.toUpperCase()) + v);
        }
        line = parts.join(' ') + "\r";
        this.command_queue.push(line);
        return this.decommand_queue();
      } else {
        return util.log("GCode for command '" + cmd + "' not found.");
      }
    };

    Printer.prototype.decommand_queue = function() {
      if (this.command_queue.length > 0 && this.state === 'prompt') {
        this.current_line = this.command_queue.shift();
        util.log("Sending: " + this.current_line);
        this.serial.write(this.current_line);
        this.transition('feedback', true);
        return true;
      } else {
        util.log("No decommand_queue for now (" + this.state + ")");
        return false;
      }
    };

    Printer.prototype.responses_since = function(start, page_size) {
      var len;
      if (page_size == null) page_size = 1000;
      len = this.response_queue.length;
      if (len > 0 && start < len) {
        return this.response_queue.slice(start, len - start);
      } else {
        return [];
      }
    };

    Printer.prototype.transition = function(state, reprocess_line) {
      var transition_fn, _i, _len, _ref;
      if (reprocess_line == null) reprocess_line = false;
      util.log("Transition from " + this.state + " to " + state);
      _ref = ["" + this.state + "_", "_" + state, "" + this.state + "_" + state];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        transition_fn = _ref[_i];
        if (transition_fn in this) {
          util.log("Calling " + transition_fn);
          this[transition_fn]();
        }
      }
      this.state = state;
      if (reprocess_line) return this[this.state](this.current_line);
    };

    Printer.prototype._offline = function() {
      this.start_signals = 0;
      return this.emit('offline');
    };

    Printer.prototype.offline = function(line) {
      if (line.indexOf('start') === 0) {
        this.start_signals += 1;
        return this.transition('contact');
      } else {
        return util.log("Offline. Ignoring: " + line);
      }
    };

    Printer.prototype._contact = function() {
      var _this = this;
      timeout(2000, function() {
        return _this.transition('lobby');
      });
      return this.emit('contact');
    };

    Printer.prototype.contact = function(line) {
      if (line.indexOf('start') === 0) {
        this.start_signals += 1;
        return util.log("Extra 'start' signal detected.");
      } else {
        return util.log("Contact. Ignoring: " + line);
      }
    };

    Printer.prototype._lobby = function(line) {
      util.log("Start signals received: " + this.start_signals);
      return this.serial.write("M105\r");
    };

    Printer.prototype.lobby = function(line) {
      if (line.indexOf('ok') === 0) {
        return this.transition('prompt', true);
      } else {
        return util.log("Lobby. Ignoring: " + line);
      }
    };

    Printer.prototype.lobby_ = function(line) {
      return this.emit('online');
    };

    Printer.prototype.feedback = function(line) {
      if (line.indexOf('ok') === 0) {
        this.transition('prompt', true);
        return this.decommand_queue();
      } else {
        return this.react(line);
      }
    };

    Printer.prototype.prompt = function(line) {
      return this.react(line);
    };

    return Printer;

  })();

  module.exports.Printer = Printer;

}).call(this);
